{"version":3,"file":"storage.js","sources":["utils/storage.js"],"sourcesContent":["// src/utils/storage.js\n\nconst BACKUP_KEY = \"habits_backup\";\nconst LAST_BACKUP_TIME_KEY = \"last_backup_time\";\nconst AUTO_BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 小时\n\n/**\n * 自动备份检查，如果上次备份时间超过24小时，则执行备份\n */\nexport function checkAutoBackup() {\n    const lastBackupTime = uni.getStorageSync(LAST_BACKUP_TIME_KEY) || 0;\n    const now = Date.now();\n    if (now - lastBackupTime >= AUTO_BACKUP_INTERVAL) {\n        return backupData();\n    }\n    return false;\n}\n\n/**\n * 执行数据备份，将 habits 数据保存到 storage 及文件中\n */\nexport function backupData() {\n    try {\n        const habits = uni.getStorageSync(\"habits\") || [];\n        if (habits.length === 0) return false;\n        const backup = {\n            timestamp: Date.now(),\n            data: habits,\n            version: \"1.0\"\n        };\n        uni.setStorageSync(BACKUP_KEY, backup);\n        saveBackupToFile(backup);\n        uni.setStorageSync(LAST_BACKUP_TIME_KEY, backup.timestamp);\n        return true;\n    } catch (error) {\n        console.error(\"备份数据失败:\", error);\n        return false;\n    }\n}\n\n/**\n * 将备份数据保存到文件中（仅限支持文件系统的平台，如微信小程序）\n */\nfunction saveBackupToFile(backup) {\n    const fs = uni.getFileSystemManager();\n    const fileName = `habits_backup_${new Date().toISOString().replace(/[:.]/g, \"-\")}.json`;\n    const userPath = `${uni.env.USER_DATA_PATH}/backups`;\n    try {\n        // 检查文件夹是否存在，不存在则创建\n        try {\n            fs.accessSync(userPath);\n        } catch (e) {\n            fs.mkdirSync(userPath, true);\n        }\n        fs.writeFileSync(`${userPath}/${fileName}`, JSON.stringify(backup), \"utf8\");\n        cleanupOldBackups(fs, userPath);\n    } catch (error) {\n        console.error(\"保存备份文件失败:\", error);\n    }\n}\n\n/**\n * 清理旧的备份文件，只保留最新的5个备份文件\n */\nfunction cleanupOldBackups(fs, backupPath) {\n    try {\n        const files = fs.readdirSync(backupPath);\n        const backupFiles = files.filter(f => f.startsWith(\"habits_backup_\"));\n        if (backupFiles.length > 5) {\n            backupFiles\n                .sort()\n                .slice(0, backupFiles.length - 5)\n                .forEach(file => {\n                    try {\n                        fs.unlinkSync(`${backupPath}/${file}`);\n                    } catch (e) {\n                        console.error(\"删除旧备份文件失败:\", e);\n                    }\n                });\n        }\n    } catch (error) {\n        console.error(\"清理旧备份失败:\", error);\n    }\n}\n\n/**\n * 从备份中恢复数据（默认模式为 full 恢复）\n */\nexport function restoreFromBackup(options = { mode: \"full\" }) {\n    try {\n        const backup = uni.getStorageSync(BACKUP_KEY);\n        if (backup && backup.data) {\n            return restoreData(backup.data, options);\n        }\n        return restoreFromFile(options);\n    } catch (error) {\n        console.error(\"恢复数据失败:\", error);\n        return {\n            success: false,\n            message: \"恢复数据失败\",\n            error\n        };\n    }\n}\n\n/**\n * 从备份文件中恢复数据\n */\nfunction restoreFromFile(options = { mode: \"full\" }) {\n    const fs = uni.getFileSystemManager();\n    const backupPath = `${uni.env.USER_DATA_PATH}/backups`;\n    try {\n        const files = fs.readdirSync(backupPath);\n        const backupFiles = files.filter(f => f.startsWith(\"habits_backup_\")).sort().reverse();\n        if (backupFiles.length === 0) {\n            return {\n                success: false,\n                message: \"未找到可用的备份文件\"\n            };\n        }\n        const latestBackup = fs.readFileSync(`${backupPath}/${backupFiles[0]}`, \"utf8\");\n        const backupDataObj = JSON.parse(latestBackup);\n        return restoreData(backupDataObj.data, options);\n    } catch (error) {\n        console.error(\"从备份文件恢复失败:\", error);\n        return {\n            success: false,\n            message: \"从备份文件恢复失败\",\n            error\n        };\n    }\n}\n\n/**\n * 根据不同模式恢复数据\n * - full 模式：完全使用备份数据覆盖当前数据\n * - merge 模式：将备份数据与当前数据合并\n */\nfunction restoreData(backupData, options = { mode: \"full\" }) {\n    try {\n        const currentHabits = uni.getStorageSync(\"habits\") || [];\n        let restoredHabits = [];\n        switch (options.mode) {\n            case \"full\":\n                restoredHabits = backupData;\n                break;\n            case \"merge\":\n                restoredHabits = mergeHabits(currentHabits, backupData);\n                break;\n            default:\n                throw new Error(\"不支持的恢复模式\");\n        }\n        uni.setStorageSync(\"habits\", restoredHabits);\n        return {\n            success: true,\n            message: \"数据恢复成功\",\n            restoredCount: restoredHabits.length,\n            timestamp: Date.now()\n        };\n    } catch (error) {\n        console.error(\"恢复数据失败:\", error);\n        return {\n            success: false,\n            message: error.message || \"恢复数据失败\",\n            error\n        };\n    }\n}\n\n/**\n * 将当前习惯数据与备份数据进行合并\n */\nfunction mergeHabits(currentHabits, backupHabits) {\n    const mergedHabits = [...currentHabits];\n    backupHabits.forEach(backupHabit => {\n        const existingIndex = mergedHabits.findIndex(h => h.id === backupHabit.id);\n        if (existingIndex === -1) {\n            mergedHabits.push(backupHabit);\n        } else {\n            const currentHabit = mergedHabits[existingIndex];\n            if (backupHabit.updateTime > currentHabit.updateTime) {\n                const mergedCompleted = [...new Set([...currentHabit.completed, ...backupHabit.completed])];\n                const mergedNotes = mergeNotes(currentHabit.notes || [], backupHabit.notes || []);\n                mergedHabits[existingIndex] = {\n                    ...backupHabit,\n                    completed: mergedCompleted,\n                    notes: mergedNotes\n                };\n            }\n        }\n    });\n    return mergedHabits;\n}\n\n/**\n * 合并备注数据，按时间降序排列\n */\nfunction mergeNotes(currentNotes, backupNotes) {\n    const notesMap = new Map();\n    [...currentNotes, ...backupNotes].forEach(note => {\n        const key = `${note.timestamp}_${note.content}`;\n        const existingNote = notesMap.get(key);\n        if (!existingNote || note.saveTimestamp > existingNote.saveTimestamp) {\n            notesMap.set(key, note);\n        }\n    });\n    return Array.from(notesMap.values()).sort((a, b) => b.timestamp - a.timestamp);\n}\n\n/**\n * 检查是否存在可用的备份数据\n */\nexport function checkBackupAvailable() {\n    try {\n        const backup = uni.getStorageSync(BACKUP_KEY);\n        if (backup && backup.data) {\n            return {\n                available: true,\n                timestamp: backup.timestamp,\n                source: \"storage\"\n            };\n        }\n        const fs = uni.getFileSystemManager();\n        const backupPath = `${uni.env.USER_DATA_PATH}/backups`;\n        try {\n            const files = fs.readdirSync(backupPath);\n            const backupFiles = files.filter(f => f.startsWith(\"habits_backup_\"));\n            if (backupFiles.length > 0) {\n                const latestBackup = JSON.parse(\n                    fs.readFileSync(`${backupPath}/${backupFiles[backupFiles.length - 1]}`, \"utf8\")\n                );\n                return {\n                    available: true,\n                    timestamp: latestBackup.timestamp,\n                    source: \"file\"\n                };\n            }\n        } catch (e) {\n            // 忽略错误\n        }\n        return {\n            available: false\n        };\n    } catch (error) {\n        console.error(\"检查备份失败:\", error);\n        return {\n            available: false,\n            error\n        };\n    }\n}"],"names":["uni"],"mappings":"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"}